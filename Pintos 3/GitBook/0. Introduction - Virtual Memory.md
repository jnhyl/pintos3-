지금쯤이면 여러분은 Pintos의 내부 동작에 어느 정도 익숙해졌을 것입니다. 여러분의 OS는 올바른 동기화와 함께 여러 실행 스레드를 적절히 처리할 수 있고, 동시에 여러 사용자 프로그램을 로드할 수 있습니다. 그러나 실행 가능한 프로그램의 **개수**와 **크기**는 머신의 주(메인) 메모리 크기에 의해 제한됩니다. 이 과제에서는, 무한한 메모리가 있는 듯한 **환영(illusion)**을 만들어 그 제한을 제거할 것입니다.

이 과제는 지난 과제 위에 구축됩니다. 프로젝트 2의 테스트 프로그램은 프로젝트 3에서도 동작해야 합니다. 프로젝트 3을 시작하기 전에 프로젝트 2 제출물의 버그를 반드시 고치십시오. 그렇지 않으면 그 버그들이 프로젝트 3에서도 동일한 문제를 야기할 가능성이 매우 큽니다.

프로젝트 3을 위해, 여러분의 이해를 돕기 위한 **단계별 가이드**를 제공합니다.

---

## Background

### Source Files

이 프로젝트에서는 `vm` 디렉터리에서 작업하게 됩니다. `Makefile`은 `-DVM` 설정이 켜지도록 업데이트되어 있습니다. 매우 많은 **템플릿 코드**를 제공합니다. **반드시 제공된 템플릿을 따라야 합니다.** 즉, **제공된 템플릿을 기반으로 하지 않은 코드**를 제출하면 **0점**입니다. 또한, 템플릿에서 **"DO NOT CHANGE"**라고 표시된 부분은 절대 변경하면 안 됩니다. 여기서는 여러분이 수정하게 될 각 템플릿 파일에 대한 세부 사항을 간단히 설명합니다.

- `include/vm/vm.h`, `vm/vm.c`  
    가상 메모리를 위한 일반 인터페이스를 제공합니다. 헤더 파일에는 여러분의 가상 메모리 시스템이 지원해야 하는 다양한 `vm_type` — `VM_UNINIT`, `VM_ANON`, `VM_FILE`, `VM_PAGE_CACHE` — 의 정의와 설명이 있습니다(지금은 `VM_PAGE_CACHE`는 무시하세요. 이는 프로젝트 4용입니다). 또한 여기서 **보조(보충) 페이지 테이블**(supplementary page table)을 구현하게 됩니다(아래 참조).
    
- `include/vm/uninit.h`, `vm/uninit.c`  
    **초기화되지 않은 페이지**( `vm_type = VM_UNINIT` )에 대한 연산을 제공합니다. 현재 설계에서는 모든 페이지가 처음에는 **UNINIT 페이지**로 설정되고, 이후 **anonymous 페이지** 또는 **file-backed 페이지**로 변환됩니다.
    
- `include/vm/anon.h`, `vm/anon.c`  
    **anonymous 페이지**( `VM_ANON` )에 대한 연산을 제공합니다.
    
- `include/vm/file.h`, `vm/file.c`  
    **file-backed 페이지**( `VM_FILE` )에 대한 연산을 제공합니다.
    
- `include/vm/inspect.h`, `vm/inspect.c`  
    채점용 **메모리 검사** 연산을 포함합니다. **이 파일들은 변경하지 마십시오.**
    

여러분이 이 프로젝트에서 작성하는 대부분의 코드는 `vm` 디렉터리에 위치하며, 이전 프로젝트에서 소개된 파일들에도 변경이 있을 수 있습니다. 아마도 몇몇 파일은 이번에 처음 접하게 될 텐데, 예를 들면 다음과 같습니다.

- `include/devices/block.h`, `devices/block.c`  
    블록 디바이스에 대한 섹터 단위 읽기/쓰기 접근을 제공합니다. **스왑 파티션**을 블록 디바이스로 접근할 때 이 인터페이스를 사용합니다.
    

---

## Memory Terminology

메모리와 저장 장치에 관한 용어를 소개합니다. 이들 중 일부는 프로젝트 2(“Virtual Memory Layout” 참조)에서 이미 익숙하겠지만, 새로운 내용도 많습니다.

### Pages

**페이지**(때때로 **가상 페이지**라고도 함)는 **연속적인 가상 메모리 영역**으로, 크기는 **4,096 바이트**(페이지 크기)입니다. 페이지는 반드시 **페이지 정렬(page-aligned)** 되어야 하며, 즉 가상 주소가 페이지 크기로 **나누어떨어지는** 지점에서 시작해야 합니다. 그러므로 64비트 가상 주소의 **하위 12비트**는 **페이지 오프셋(offset)** 입니다. 상위 비트들은 곧 소개할 **페이지 테이블 인덱스**로 사용됩니다. 64비트 시스템에서는 **4단계 페이지 테이블**을 사용하며, 가상 주소는 다음과 같습니다:

```
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                          Virtual Address
```

각 프로세스는 **사용자(가상) 페이지**의 독립된 집합을 갖습니다. 이는 `KERN_BASE (0x8004000000)` 아래의 페이지를 의미합니다. 반면 **커널(가상) 페이지**의 집합은 **전역적**이며, 어떤 스레드나 프로세스가 실행 중이든 동일한 위치를 유지합니다. **커널은 사용자·커널 페이지 모두 접근**할 수 있지만, **사용자 프로세스는 자기 자신의 사용자 페이지**만 접근할 수 있습니다. 자세한 내용은 **Virtual Memory Layout**을 참조하세요.

Pintos는 가상 주소를 다루는 데 유용한 여러 함수를 제공합니다. 자세한 내용은 **Section Virtual Addresses**를 보십시오.

### Frames

**프레임**(때때로 **물리 프레임** 또는 **페이지 프레임**)은 **연속적인 물리 메모리 영역**입니다. 페이지와 마찬가지로, 프레임도 페이지 크기이며 페이지 정렬되어야 합니다. 따라서 64비트 **물리 주소**는 다음과 같이 **프레임 번호**와 **프레임 오프셋**(offset)으로 나뉩니다:

```
                          12 11         0
    +-----------------------+-----------+
    |      Frame Number     |   Offset  |
    +-----------------------+-----------+
              Physical Address
```

x86-64는 물리 주소의 메모리를 직접 접근하는 방법을 제공하지 않습니다. Pintos는 **커널 가상 메모리를 물리 메모리에 직접 매핑**함으로써 이를 우회합니다 — 커널 가상 메모리의 첫 페이지는 물리 메모리의 첫 프레임에, 두 번째 페이지는 두 번째 프레임에, … 이런 식으로 매핑됩니다. 따라서 프레임은 **커널 가상 메모리**를 통해 접근할 수 있습니다.

Pintos는 물리 주소와 커널 가상 주소 간의 변환을 위한 함수를 제공합니다. 자세한 내용은 **Virtual Addresses**를 참조하세요.

### Page Tables

**페이지 테이블**은 CPU가 **가상 주소를 물리 주소로 변환**(즉, 페이지 → 프레임)하기 위해 사용하는 자료구조입니다. 페이지 테이블 형식은 x86-64 아키텍처에 의해 규정됩니다. Pintos는 `threads/mmu.c`에 페이지 테이블 관리 코드를 제공합니다.

아래 도표는 페이지와 프레임 간의 관계를 보여줍니다. 왼쪽의 가상 주소는 **페이지 번호**와 **오프셋**으로 구성됩니다. 페이지 테이블은 페이지 번호를 프레임 번호로 변환하고, 변환된 프레임 번호에 **변경되지 않은 오프셋**을 결합하여 오른쪽의 **물리 주소**를 얻습니다.

```
                          +----------+
         .--------------->|Page Table|-----------.
        /                 +----------+            |
        |   12 11 0                               V  12 11 0
    +---------+----+                         +---------+----+
    | Page Nr | Ofs|                         |Frame Nr | Ofs|
    +---------+----+                         +---------+----+
     Virt Addr   |                            Phys Addr    ^
                  \_______________________________________/
```

### Swap Slots

**스왑 슬롯**은 스왑 파티션 내의 **페이지 크기** 디스크 공간입니다. 하드웨어 제약으로 인해 슬롯 배치에 대한 제한은 프레임보다 더 유연하지만, **페이지 정렬**하는 것이 좋습니다. 그렇게 해도 손해가 없기 때문입니다.

---

## Resource Management Overview

여러분은 다음과 같은 자료구조를 설계/구현해야 합니다.

- **보조(보충) 페이지 테이블 (Supplemental page table)**  
    페이지 테이블을 보완하여 **페이지 폴트 처리**를 가능하게 합니다. 아래 **Managing the Supplemental Page Table**을 보십시오.
    
- **프레임 테이블 (Frame table)**  
    물리 프레임의 **축출(eviction) 정책**을 효율적으로 구현할 수 있도록 합니다. 아래 **Managing the Frame Table**을 보십시오.
    
- **스왑 테이블 (Swap table)**  
    스왑 슬롯의 사용을 추적합니다. 아래 **Managing the Swap Table**을 보십시오.
    

세 자료구조를 반드시 완전히 분리하여 구현할 필요는 없습니다. 관련 리소스를 전체 또는 일부 통합하여 **통합 자료구조**로 구현하는 것이 편리할 수 있습니다.

각 자료구조에 대해, **각 원소가 포함해야 할 정보**를 결정해야 합니다. 또한 자료구조의 **범위(scope)** — **로컬(프로세스별)** 혹은 **전역(시스템 전체)** — 와, 그 범위 내에서 **인스턴스 수**를 결정해야 합니다.

설계를 단순화하기 위해, 이러한 자료구조는 **non-pageable 메모리**(예: `calloc` 또는 `malloc`으로 할당한 메모리)에 저장해도 됩니다. 즉, 이들 사이의 포인터가 유효하게 유지된다는 점을 보장할 수 있습니다.

---

## Choices of implementation (Performance perspective)

가능한 구현 선택지는 **배열**, **리스트**, **비트맵**, **해시 테이블** 등이 있습니다. **배열**은 종종 가장 단순하지만, **희소(sparse)** 하게 채워질 경우 메모리를 낭비합니다. **리스트**도 단순하지만, 특정 위치를 찾기 위해 **긴 리스트를 순회**하는 것은 시간을 낭비합니다. 배열과 리스트는 둘 다 **크기 조정**이 가능하지만, **중간 삽입/삭제**는 리스트가 더 효율적으로 지원합니다.

Pintos에는 `lib/kernel/bitmap.c` 및 `include/lib/kernel/bitmap.h`에 **비트맵 자료구조**가 포함되어 있습니다. **비트맵**은 **true/false** 값을 가지는 비트들의 배열입니다. 비트맵은 일반적으로 (동일한) 자원 집합의 사용 여부를 추적하는 데 사용됩니다: 자원 n이 사용 중이면 비트맵의 n번째 비트가 true입니다. Pintos의 비트맵은 **고정 크기**입니다. (원한다면 **크기 조정**을 지원하도록 구현을 확장할 수 있습니다.)

Pintos에는 **해시 테이블 자료구조**도 포함되어 있습니다(“Hash Table” 참조). Pintos의 해시 테이블은 폭넓은 테이블 크기 범위에서 **삽입/삭제**를 효율적으로 지원합니다.

보다 복잡한 자료구조가 더 나은 성능 또는 다른 이점을 줄 수도 있지만, 구현을 불필요하게 복잡하게 만들 수 있습니다. 따라서 우리는 **균형 이진 트리** 같은 **고급 자료구조**를 설계의 일환으로 구현하는 것을 권장하지 않습니다.

---

## Managing the Supplemental Page Table

**보조(보충) 페이지 테이블**은 각 페이지에 대한 추가 데이터를 제공하여 페이지 테이블을 보완합니다. 이는 페이지 테이블 형식이 부과하는 **제약** 때문에 필요합니다. 이러한 자료구조는 흔히 “페이지 테이블”이라고도 불리므로, 혼동을 줄이기 위해 “supplemental”이라는 단어를 덧붙입니다.

보조 페이지 테이블은 **적어도 두 가지 목적**으로 사용됩니다. 가장 중요하게는, **페이지 폴트** 발생 시 커널은 보조 페이지 테이블에서 **폴트가 난 가상 페이지를 조회**하여 그 페이지에 어떤 데이터가 있어야 하는지 알아냅니다. 두 번째로, **프로세스 종료 시**, 커널은 **해제할 리소스**를 결정하기 위해 보조 페이지 테이블을 참조합니다.

### Organization of Supplemental Page Table

보조 페이지 테이블의 구성은 자유롭게 정할 수 있습니다. 기본적인 접근법으로는 적어도 두 가지가 있습니다: **세그먼트(segments)** 관점과 **페이지(pages)** 관점입니다. 여기서 **세그먼트**는 연속된 페이지들의 그룹(예: 실행 파일이나 메모리 매핑 파일을 포함하는 메모리 영역)을 의미합니다.

선택적으로, 보조 페이지 테이블의 멤버를 추적하기 위해 **페이지 테이블 자체**를 사용할 수도 있습니다. 그렇게 하려면 `threads/mmu.c`의 Pintos 페이지 테이블 구현을 수정해야 합니다. 이 접근은 **고급 학생들에게만 권장**됩니다.

### Handling page fault

보조 페이지 테이블의 가장 중요한 사용자는 **페이지 폴트 핸들러**입니다. 프로젝트 2에서는 페이지 폴트가 항상 커널 또는 사용자 프로그램의 버그를 의미했습니다. 프로젝트 3에서는 그렇지 않습니다. 이제 페이지 폴트는 단지 **파일이나 스왑 슬롯에서 페이지를 가져와야 함**을 의미할 수 있습니다. 이러한 경우를 처리하기 위해 더 정교한 페이지 폴트 핸들러를 구현해야 합니다. 페이지 폴트 핸들러는 `userprog/exception.c`의 `page_fault()`이며, 이 함수가 여러분의 핸들러 `vm_try_handle_fault()` (`vm/vm.c`)를 호출합니다. 여러분의 페이지 폴트 핸들러는 대략 다음을 수행해야 합니다.

1. **폴트가 난 페이지를 보조 페이지 테이블에서 찾습니다.** 메모리 참조가 유효하다면, 보조 페이지 테이블 엔트리를 사용하여 그 페이지에 들어갈 데이터를 찾습니다. 데이터는 **파일 시스템**에 있을 수도 있고, **스왑 슬롯**에 있을 수도 있으며, 단순히 **모두 0(zero)인 페이지**일 수도 있습니다. **공유(예: Copy-on-Write)** 를 구현한다면, 페이지의 데이터가 이미 **페이지 테이블에는 없는** 어떤 **페이지 프레임**에 존재할 수도 있습니다. 반대로, 보조 페이지 테이블이 사용자 프로세스가 접근하려는 주소에 **어떠한 데이터도 기대하지 않음**을 나타내거나, 그 페이지가 **커널 가상 메모리 내**에 있거나, **읽기 전용 페이지에 쓰기**를 시도했다면, 그 접근은 **무효**입니다. **모든 무효 접근은 프로세스를 종료**시키며, 이로써 해당 프로세스의 모든 리소스가 해제됩니다.
    
2. **페이지를 담을 프레임을 획득**합니다. 공유를 구현한다면, 필요한 데이터가 이미 어떤 프레임에 있을 수 있습니다. 그 경우 그 프레임을 **찾아낼 수 있어야** 합니다.
    
3. **데이터를 프레임으로 가져옵니다.** 파일 시스템이나 스왑에서 읽거나, 0으로 채우는 등의 작업을 수행합니다. 공유를 구현했다면, 필요한 페이지가 이미 프레임에 있을 수 있으므로 이 단계에서는 **아무 작업도 필요 없을** 수 있습니다.
    
4. **폴트가 난 가상 주소에 대한 페이지 테이블 엔트리를 물리 페이지로 가리키도록** 설정합니다. 이를 위해 `threads/mmu.c`의 함수들을 사용할 수 있습니다.
    

---

## Managing the Frame Table

**프레임 테이블**은 **각 프레임마다 하나의 엔트리**를 갖습니다. 각 엔트리에는 그 프레임을 현재 점유하는 **페이지에 대한 포인터(있다면)** 와, 여러분이 선택한 **그 밖의 데이터**가 들어갑니다. 프레임 테이블은 **프레임이 비어 있지 않을 때** 축출 정책을 구현하여 **축출 대상 페이지 선택**을 효율적으로 하도록 해줍니다.

**사용자 페이지에 사용되는 프레임**은 반드시 **“user pool”** 에서 얻어야 하며, `palloc_get_page(PAL_USER)`를 호출해 할당받으십시오. **반드시 `PAL_USER`를 사용**해야 합니다. 그렇지 않으면 **“kernel pool”** 에서 할당되어 일부 테스트 케이스가 예상치 못하게 실패할 수 있습니다. 프레임 테이블 구현의 일환으로 `palloc.c`를 수정하더라도, **두 풀의 구분**은 반드시 유지해야 합니다.

프레임 테이블에서 가장 중요한 연산은 **사용되지 않은 프레임을 얻는 것**입니다. 프레임이 자유(free)라면 쉽습니다. **자유 프레임이 없다면**, 어떤 페이지를 축출하여 프레임을 비워야 합니다.

만약 **스왑 슬롯을 할당하지 않고는** 축출할 수 있는 프레임이 없는데, **스왑이 가득 찼다면**, **커널 패닉**을 일으키십시오. 실제 OS들은 이런 상황을 복구하거나 예방하기 위해 다양한 정책을 적용하지만, 이는 본 프로젝트의 범위를 벗어납니다.

**축출(eviction) 과정**은 대략 다음과 같습니다.

1. **페이지 교체 알고리즘**을 사용해 **축출할 프레임을 선택**합니다. 아래 설명할 **accessed 비트**와 **dirty 비트**가 유용합니다.
    
2. 그 프레임을 참조하는 모든 페이지 테이블에서 **프레임에 대한 참조를 제거**합니다. **공유**를 구현하지 않았다면, 어느 시점에도 **단 하나의 페이지만** 프레임을 참조해야 합니다.
    
3. 필요하다면, 그 페이지를 **파일 시스템** 또는 **스왑**에 **기록(write-back)** 합니다. 그러면 축출된 프레임을 다른 페이지를 저장하는 데 사용할 수 있습니다.
    

### Accessed and Dirty Bits

x86-64 하드웨어는 페이지 교체 알고리즘 구현을 위해 각 페이지의 PTE(페이지 테이블 엔트리)에 있는 **두 비트**를 제공합니다.

- **accessed 비트**: 해당 페이지에 **읽기 또는 쓰기**가 발생하면 CPU가 1로 설정합니다.
    
- **dirty 비트**: 해당 페이지에 **쓰기**가 발생하면 CPU가 1로 설정합니다.
    

CPU는 이 비트들을 **다시 0으로 리셋하지 않지만**, OS는 **리셋할 수 있습니다**.

**alias(별칭)** — 즉, **동일한 프레임을 참조하는 두 개(이상)의 페이지** — 에 주의해야 합니다. 별칭 프레임이 접근되면 accessed/dirty 비트는 **접근에 사용된 페이지의 PTE에만** 반영됩니다. **다른 별칭**의 PTE 비트는 업데이트되지 않습니다.

Pintos에서는 **모든 사용자 가상 페이지**가 **자신의 커널 가상 페이지**에 대해 **별칭(alias)** 을 가집니다. 여러분은 이 별칭들을 **어떤 방식으로든 관리**해야 합니다. 예를 들어, **양쪽 주소**에 대해 accessed/dirty 비트를 **검사 및 갱신**하도록 만들 수 있습니다. 또는, 커널이 **사용자 데이터에 접근할 때 사용자 가상 주소만 사용**하도록 하여 문제를 회피할 수도 있습니다.

기타 별칭은 **공유를 구현한 경우**나, **여러분의 코드에 버그가 있는 경우**에만 발생해야 합니다.

**Page Table Accessed and Dirty Bits** 섹션에서 accessed/dirty 비트를 다루는 함수들에 대한 자세한 내용을 확인할 수 있습니다.

---

## Managing the Swap Table

**스왑 테이블**은 **사용 중/자유 스왑 슬롯**을 추적합니다. 축출 시 페이지를 스왑 파티션에 내보내기 위해 **미사용 스왑 슬롯을 선택**할 수 있어야 합니다. 또한, 페이지가 **프레임으로 다시 읽혀** 오거나, 그 페이지의 프로세스가 종료되었을 때 **스왑 슬롯을 해제**할 수 있어야 합니다.

`vm/build` 디렉터리에서 다음 명령을 사용하여 스왑 파티션을 포함하는 `swap.dsk` 디스크를 만들 수 있습니다.

```
pintos-mkdisk swap.dsk --swap-size=n
```

이렇게 하면 **n MB** 크기의 스왑 파티션을 가진 `swap.dsk`가 생성됩니다. 이후 `pintos`를 실행하면 `swap.dsk`가 자동으로 **추가 디스크**로 연결됩니다. 또는, 다음과 같이 한 번의 실행 동안만 유효한 임시 **n MB 스왑 디스크**를 사용하도록 `pintos`에 지시할 수 있습니다.

```
--swap-size=n
```

스왑 슬롯은 **지연(lazy) 할당**되어야 합니다. 즉, **축출로 실제로 필요해지는 시점에만** 할당해야 합니다. **프로세스 시작 시** 실행 파일의 데이터 페이지들을 읽어와 **즉시 스왑에 쓰는 것**은 지연 할당이 아닙니다. 또한 **특정 페이지를 저장하기 위해** 스왑 슬롯을 **미리 예약**해서도 안 됩니다.

페이지의 내용이 **프레임으로 다시 읽혀 들어오면**, 해당 **스왑 슬롯을 해제**하십시오.

---

## Managing Memory Mapped Files

파일 시스템은 가장 흔하게 **read/write 시스템 콜**로 접근됩니다. **보조적인 인터페이스**로, `mmap` 시스템 콜을 사용하여 파일을 **가상 페이지에 “매핑”** 할 수 있습니다. 그러면 프로그램은 **파일 데이터에 대해 메모리 명령을 직접** 사용할 수 있습니다. 예를 들어, 파일 `foo`의 길이가 **0x1000 바이트(4 kB, 즉 한 페이지)** 라고 합시다. 만약 `foo`가 **0x5000** 주소에서 시작하도록 메모리에 매핑되었다면, **0x5000 … 0x5fff** 위치에 대한 모든 메모리 접근은 `foo`의 대응 바이트들을 접근하게 됩니다.

다음은 `mmap`을 사용하여 파일을 콘솔에 출력하는 프로그램입니다. 명령줄로 지정된 파일을 열고, 이를 가상 주소 **0x10000000**에 매핑한 뒤, 매핑된 데이터를 콘솔(fd 1)로 쓰고, 마지막으로 매핑을 해제(`munmap`)합니다.

```c
#include <stdio.h>
#include <syscall.h>
int main (int argc UNUSED, char *argv[])
{
  void *data = (void *) 0x10000000;                 /* Address at which to map. */
  int fd = open (argv[1]);                          /* Open file. */
  void *map = mmap (data, filesize (fd), 0, fd, 0); /* Map file. */
  write (1, data, filesize (fd));                   /* Write file to console. */
  munmap (map);                                     /* Unmap file (optional). */
  return 0;
}
```

여러분의 제출물은 **메모리 매핑 파일이 사용하는 메모리**를 **추적**할 수 있어야 합니다. 이는 **매핑된 영역에서의 페이지 폴트**를 올바르게 처리하고, **매핑된 파일들이 프로세스 내의 다른 어떤 세그먼트와도 겹치지 않도록** 보장하기 위해 필요합니다.