# Anonymous Page
이 프로젝트의 이 부분에서는 디스크 기반이 아닌 이미지인 **anonymous page**를 구현하게 됩니다.

**Anonymous 매핑**은 백업하는 파일이나 디바이스가 없습니다. 파일에 의해 이름 붙여진 소스(파일-backed 페이지와 달리)가 없기 때문에 anonymous라고 부릅니다. Anonymous 페이지는 스택과 힙처럼 실행 파일에서 사용됩니다.

`include/vm/anon.h`에는 anonymous 페이지를 설명하는 구조체인 **`anon_page`** 가 있습니다. 현재는 비어 있지만, 구현하면서 anonymous 페이지의 **필요한 정보나 상태**를 저장하기 위해 멤버를 추가할 수 있습니다. 또한 **`include/vm/page.h`** 의 `struct page`를 보세요. 이 구조체는 페이지의 **일반적인 정보**를 포함합니다. Anonymous 페이지의 경우, `struct page` 안에 **`struct anon_page anon`** 이 포함된다는 점에 주의하세요.

---

## Page Initialization with Lazy Loading

**Lazy loading**은 메모리의 로딩을 **필요 시점까지 지연**하는 설계입니다. 즉, 페이지가 **할당**되어 `struct page`는 존재하지만, **전용 물리 프레임은 없고** 페이지의 **실제 내용도 아직 로드되지 않은** 상태입니다. 그 내용은 **정말로 필요해지는 순간**, 즉 **페이지 폴트**가 신호를 줄 때 로드됩니다.

세 가지 페이지 타입이 있으므로, **초기화 루틴은 타입마다 다릅니다**. 아래 섹션에서 다시 설명하겠지만, 여기서는 **페이지 초기화 흐름**의 상위 개요를 제공합니다. 먼저, **`vm_alloc_page_with_initializer`** 가 **커널이 새로운 페이지 요청을 받았을 때** 호출됩니다. 이 **initializer**는 **새 페이지를 초기화**하는데, 페이지 구조체를 할당하고 **페이지 타입에 맞는 initializer**를 설정한 뒤, **사용자 프로그램에 제어를 반환**합니다. 사용자 프로그램이 실행되다가 어느 시점에서, **프로그램이 가지고 있다고 생각하는 페이지를 접근하지만 아직 내용이 없는** 탓에 **페이지 폴트**가 발생합니다. 폴트 처리 과정 동안 **`uninit_initialize`** 가 호출되고, **앞서 설정해 둔 initializer** 를 호출합니다. Anonymous 페이지의 경우 initializer는 **`anon_initializer`**, 파일-backed 페이지의 경우 **`file_backed_initializer`** 입니다.

페이지의 생명주기는 **`initialize -> (page_fault -> lazy-load -> swap-in -> swap-out -> ...) -> destroy`** 가 될 수 있습니다. 생명주기의 각 전이마다 필요한 절차는 **페이지 타입(VM_TYPE)** 에 따라 다릅니다(위 단락은 초기화에 대한 예시). 이 프로젝트에서는 **각 페이지 타입**에 대해 이러한 **전이 절차**를 구현하게 됩니다.

---

## Lazy Loading for Executable

Lazy loading에서는 **프로세스가 실행을 시작할 때**, 즉시 필요한 메모리 부분만 **주 메모리로 로드**됩니다. 이는 **모든 바이너리 이미지를 한 번에 메모리에 올리는** eager loading에 비해 오버헤드를 줄일 수 있습니다.

Lazy loading을 지원하기 위해, `include/vm/vm.h`에 **`VM_UNINIT`** 라는 페이지 타입을 도입합니다. **모든 페이지는 처음에 `VM_UNINIT`** 페이지로 생성됩니다. 또한 **초기화되지 않은 페이지**를 위한 페이지 구조체 **`struct uninit_page`** 가 `include/vm/uninit.h`에 제공됩니다. 초기화되지 않은 페이지를 **생성/초기화/파괴**하는 함수들은 `include/vm/uninit.c`에서 찾을 수 있습니다. 이 함수들은 나중에 여러분이 **완성**해야 합니다.

페이지 폴트가 발생하면, **`userprog/exception.c`의 `page_fault`** 가 제어를 **`vm/vm.c`의 `vm_try_handle_fault`** 로 넘기고, 이 함수는 먼저 **유효한 페이지 폴트인지**를 검사합니다. 여기서 **유효(valid)** 하다는 것은 (원문 표현은 혼동되지만 문맥상) **지연 로딩 등으로 처리될 수 있는 폴트**를 의미합니다. **만약 가짜(bogus) 폴트**라면, 페이지에 **어떤 내용을 로드**한 뒤 사용자 프로그램에 제어를 반환합니다.

가짜(bogus) 페이지 폴트의 경우는 **세 가지**가 있습니다: **지연 로딩(lazy-loaded) 페이지**, **스왑-아웃된 페이지**, **쓰기 보호된 페이지**(Copy-on-Write(추가 과제) 참조). 지금은 첫 번째 경우, **lazy-loaded 페이지**만 고려하면 됩니다. 만약 lazy loading에 대한 페이지 폴트라면, 커널은 `vm_alloc_page_with_initializer`에서 미리 설정해 둔 **initializer 중 하나**를 호출하여 세그먼트를 **지연 로드**합니다. 여러분은 **`userprog/process.c`의 `lazy_load_segment`** 를 구현해야 합니다.

**`vm_alloc_page_with_initializer()`** 를 구현하십시오. 전달된 `vm_type`에 따라 **적절한 initializer를 선택**하고 **`uninit_new`** 를 그 initializer와 함께 호출해야 합니다.

```c
bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
        bool writable, vm_initializer *init, void *aux);
```

주어진 타입으로 **초기화되지 않은 페이지(uninitialized page)** 를 생성합니다. **uninit 페이지의 `swap_in` 핸들러**는 타입에 따라 페이지를 **자동으로 초기화**하고, **주어진 `AUX`로 `INIT`** 를 호출합니다. `struct page`를 확보한 뒤에는, 그 페이지를 **프로세스의 보조 페이지 테이블**에 삽입하십시오. `vm.h`에 정의된 **`VM_TYPE` 매크로**가 유용할 수 있습니다.

페이지 폴트 핸들러는 **콜 체인**을 따라가며, 최종적으로 **`swap_in`** 을 호출할 때 **`uninit_initialize`** 에 도달합니다. 이 함수의 **완전한 구현**은 제공됩니다. 다만, 여러분의 설계에 따라 **`uninit_initialize`를 수정**해야 할 수도 있습니다.

```c
static bool uninit_initialize (struct page *page, void *kva);
```

**첫 번째 폴트 시** 페이지를 초기화합니다. 템플릿 코드는 먼저 `vm_initializer`와 `aux`를 가져온 뒤, **함수 포인터**를 통해 해당하는 **`page_initializer`** 를 호출합니다. 여러분의 설계에 따라 이 함수를 **수정해야 할 수도 있습니다**.

필요에 따라 `vm/anon.c`의 **`vm_anon_init`** 과 **`anon_initializer`** 를 **수정**할 수 있습니다.

```c
void vm_anon_init (void);
```

Anonymous 페이지 **서브시스템 초기화**를 수행합니다. 이 함수에서 anonymous 페이지와 관련된 모든 설정을 할 수 있습니다.

```c
bool anon_initializer (struct page *page, enum vm_type type, void *kva);
```

이 함수는 먼저 `page->operations`에 **anonymous 페이지용 핸들러**들을 설정합니다. 현재 비어 있는 `anon_page`에 **일부 정보를 갱신**해야 할 수도 있습니다. 이 함수는 **anonymous 페이지(`VM_ANON`)의 initializer** 로 사용됩니다.

**`userprog/process.c`** 에서 **`load_segment`** 와 **`lazy_load_segment`** 를 구현하십시오. 실행 파일로부터 **세그먼트 로딩**을 구현해야 합니다. 이 **모든 페이지는 지연 로딩되어야** 하며, 즉 **커널이 해당 페이지에 대한 페이지 폴트를 가로챘을 때만** 로드되어야 합니다.

프로그램 로더의 핵심인 `userprog/process.c`의 **`load_segment` 내부 루프**를 **수정**해야 합니다. 루프를 한 번 돌 때마다, **`vm_alloc_page_with_initializer`** 를 호출하여 **대기(pending) 페이지 객체**를 만듭니다. 페이지 폴트가 발생하면, 그때 **파일에서 실제로 세그먼트를 로드**합니다.

```c
static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
        uint32_t read_bytes, uint32_t zero_bytes, bool writable);
```

현재 코드는 **메인 루프에서** 파일에서 읽을 바이트 수와 **0으로 채울 바이트 수**를 계산합니다. 그 다음, **`vm_alloc_page_with_initializer`** 를 호출하여 **대기 객체**를 생성합니다. 여러분은 **보조 값(aux)** 을 **`vm_alloc_page_with_initializer`에 전달할 인자**로 **설정**해야 합니다. 바이너리 로딩에 필요한 정보를 담는 **구조체를 새로 정의**하고 사용할 수 있습니다.

```c
static bool lazy_load_segment (struct page *page, void *aux);
```

`load_segment`에서 `vm_alloc_page_with_initializer`의 **네 번째 인자**로 **`lazy_load_segment`** 가 전달된 것을 눈치채셨을 것입니다. 이 함수는 실행 파일의 페이지에 대한 **initializer** 이며, **페이지 폴트 시** 호출됩니다. 이 함수는 `page`와 `aux`를 인자로 받습니다. `aux`는 `load_segment`에서 설정한 정보입니다. 이 정보를 사용하여 **어느 파일에서 세그먼트를 읽어야 하는지**를 찾아내고, 최종적으로 **세그먼트를 메모리로 읽어들여야** 합니다.

`userprog/process.c`의 **`setup_stack`** 도 새로운 메모리 관리 시스템에 맞게 **조정**해야 합니다. **첫 번째 스택 페이지는 지연 로딩할 필요가 없습니다.** **로드 시점**에 **명령행 인자들로 할당 및 초기화**할 수 있으며, 폴트를 기다릴 필요가 없습니다. 또한 **스택을 식별하는 방법**을 제공해야 할 수도 있습니다. `vm/vm.h`의 `vm_type`에 있는 **보조 마커(auxillary markers)** (예: `VM_MARKER_0`)를 사용하여 **해당 페이지를 표시**할 수 있습니다.

마지막으로, **`vm_try_handle_fault`** 를 수정하여, **폴트가 난 주소**에 대응하는 페이지 구조체를 **보조 페이지 테이블의 `spt_find_page`를 통해** 찾아 **해결**하도록 하십시오.

위 요구사항을 모두 구현하면, **프로젝트 2의 모든 테스트(단, `fork` 제외)** 가 통과되어야 합니다.

---

## Supplemental Page Table — Revisit

이제 **보조 페이지 테이블 인터페이스**를 다시 살펴보며 **복사(copy)** 와 **정리(clean up)** 연산을 지원하도록 합니다. 이 연산들은 **프로세스를 생성(좀 더 정확히는 자식 프로세스 생성)** 하거나 **파괴**할 때 필요합니다. 자세한 내용은 아래에 설명합니다. 이 시점에 보조 페이지 테이블을 다시 다루는 이유는, 위에서 구현한 **초기화 함수들**을 **재사용**하고 싶을 수 있기 때문입니다.

`vm/vm.c`에 **`supplemental_page_table_copy`** 와 **`supplemental_page_table_kill`** 을 구현하십시오.

```c
bool supplemental_page_table_copy (struct supplemental_page_table *dst,
    struct supplemental_page_table *src);
```

`src`의 보조 페이지 테이블을 `dst`로 **복사**합니다. 이는 자식이 부모의 **실행 컨텍스트를 상속**해야 할 때(예: `fork()`) 사용됩니다. `src`의 보조 페이지 테이블의 **각 페이지를 순회**하며, `dst`의 보조 페이지 테이블에 **엔트리를 정확히 복제**하십시오. **uninit 페이지를 할당하고 즉시 claim** 해야 합니다.

```c
void supplemental_page_table_kill (struct supplemental_page_table *spt);
```

보조 페이지 테이블이 보유하던 **모든 리소스를 해제**합니다. 이 함수는 프로세스가 **종료할 때**(`userprog/process.c`의 `process_exit()`) 호출됩니다. **페이지 엔트리들을 순회**하며, 테이블 안의 **각 페이지에 대해 `destroy(page)`** 를 호출해야 합니다. 이 함수에서는 **실제 페이지 테이블(pml4)** 과 **물리 메모리(palloc으로 할당된 메모리)** 에 대해서는 걱정할 필요가 없습니다. **호출자(caller)** 가 **보조 페이지 테이블 정리 후** 그것들을 정리합니다.

---

## Page Cleanup

`vm/uninit.c`의 **`uninit_destroy`** 와 `vm/anon.c`의 **`anon_destroy`** 를 구현하십시오. 이는 **초기화되지 않은 페이지**에 대한 **destroy 연산의 핸들러**입니다. 초기화되지 않은 페이지가 다른 페이지 객체로 **변환(transmute)** 된다 하더라도, **프로세스 종료 시** 여전히 **uninit 페이지가 남아 있을 수** 있습니다.

```c
static void uninit_destroy (struct page *page);
```

`page` 구조체가 보유하던 **리소스를 해제**합니다. 페이지의 **vm 타입을 확인**하고 그에 맞게 **처리**해야 할 수 있습니다.

지금 단계에서는 **anonymous 페이지만 처리**해도 됩니다. 나중에 이 함수를 다시 방문하여 **file-backed 페이지**도 정리하도록 확장하게 됩니다.

```c
static void anon_destroy (struct page *page);
```

Anonymous 페이지가 보유하던 **리소스를 해제**합니다. `page` 구조체 자체를 **명시적으로 해제할 필요는 없으며**, 이는 **호출자(caller)** 가 수행해야 합니다.

이제 **프로젝트 2의 모든 테스트**가 **통과**되어야 합니다.