# Swap In/Out
**메모리 스와핑**은 물리 메모리의 활용도를 극대화하기 위한 **메모리 회수(reclamation) 기법**입니다. 주 메모리의 프레임들이 이미 할당되어 **더 이상 사용자 프로그램의 메모리 할당 요청을 처리할 수 없을 때**, 해결책 중 하나는 **현재 사용 중이 아닌 메모리 프레임을 디스크로 스왑 아웃**하는 것입니다. 이렇게 하면 일부 메모리 자원을 해제하여 **다른 애플리케이션이 사용할 수 있도록** 합니다.

스와핑은 **운영체제**가 수행합니다. 시스템이 **메모리가 바닥났음**을 감지했지만 **메모리 할당 요청**을 받으면, 운영체제는 **스왑 디스크로 내보낼 페이지(축출 대상)** 를 선택합니다. 그런 다음, **메모리 프레임의 정확한 상태**를 디스크에 **복사**합니다. 프로세스가 **스왑 아웃된 페이지에 접근**하려 하면, OS는 **디스크에서 내용을 다시 가져와 메모리에 복구**합니다.

축출 대상으로 선택된 페이지는 **anonymous 페이지**일 수도 있고 **file-backed 페이지**일 수도 있습니다. 이 섹션에서는 각 경우를 처리합니다.

모든 스와핑 연산은 **명시적으로 호출되는 것이 아니라**, **함수 포인터**로 호출됩니다. 이들은 각 페이지의 **initializer**에서 등록되는 `struct page_operations`(예: `file_ops`)의 **멤버**들입니다.

---

## Anonymous Page

`vm/anon.c`의 **`vm_anon_init`** 과 **`anon_initializer`** 를 수정하십시오. Anonymous 페이지는 자체 **백업 저장소(backing storage)** 가 없습니다. Anonymous 페이지의 스와핑을 지원하기 위해, **임시 백업 저장소**인 **스왑 디스크(swap disk)** 를 제공합니다. 여러분은 **스왑 디스크를 활용**하여 anonymous 페이지의 스왑을 구현해야 합니다.

```c
void vm_anon_init (void);
```

이 함수에서는 **스왑 디스크를 설정**해야 합니다. 또한 스왑 디스크의 **자유/사용 영역**을 관리하기 위한 **자료구조**가 필요합니다. 스왑 영역은 **PGSIZE(4096바이트) 단위**로 관리됩니다.

```c
bool anon_initializer (struct page *page, enum vm_type type, void *kva);
```

이 함수는 **anonymous 페이지의 initializer** 입니다. 스와핑을 지원하기 위해 **`anon_page`에 일부 정보를 추가**해야 합니다.

이제 `vm/anon.c`에 **`anon_swap_in`** 과 **`anon_swap_out`** 을 구현하여 anonymous 페이지의 스와핑을 지원하십시오. 페이지가 **스왑 인** 되려면 이전에 **스왑 아웃** 되어 있어야 하므로, **`anon_swap_in`** 에 앞서 **`anon_swap_out`** 을 먼저 구현하는 것이 좋습니다. **데이터 내용을 스왑 디스크로 옮기고**, 다시 **안전하게 메모리로 가져오는** 동작을 구현해야 합니다.

```c
static bool anon_swap_in (struct page *page, void *kva);
```

스왑 디스크에서 **anonymous 페이지를 스왑 인**합니다. 즉, **디스크의 데이터 내용을 메모리로 읽어**옵니다. 데이터의 **디스크 내 위치**는 **스왑 아웃 시** `page` 구조체에 저장되어 있어야 합니다. **스왑 테이블**의 갱신을 잊지 마십시오(“Managing the Swap Table” 참조).

```c
static bool anon_swap_out (struct page *page);
```

**메모리의 내용을 디스크로 복사**하여 **anonymous 페이지를 스왑 아웃**합니다. 먼저 **스왑 테이블**을 사용해 디스크에서 **자유 스왑 슬롯**을 찾고, 해당 슬롯에 **페이지 데이터를 복사**합니다. 데이터의 **디스크 내 위치**를 `page` 구조체에 **저장**해야 합니다. **자유 슬롯이 더 이상 없다면**, **커널 패닉**을 일으켜도 됩니다.

---

## File-Mapped Page

**File-backed 페이지**의 내용은 **파일에서 유래**하므로, **매핑된 파일 자체가 백킹 스토어**가 되어야 합니다. 즉, **file-backed 페이지를 축출(evict)할 때**, **그 페이지를 매핑한 원 파일에 다시 기록(write-back)** 해야 합니다. `vm/file.c`에서 **`file_backed_swap_in`**, **`file_backed_swap_out`** 을 구현하십시오. 설계에 따라 **`file_backed_init`** 과 **`file_initializer`** 를 수정할 수도 있습니다.

```c
static bool file_backed_swap_in (struct page *page, void *kva);
```

파일에서 **내용을 읽어** `kva`에 **페이지를 스왑 인**합니다. **파일 시스템과의 동기화**가 필요합니다.

```c
static bool file_backed_swap_out (struct page *page);
```

파일에 **내용을 다시 기록**하여 **페이지를 스왑 아웃**합니다. 먼저 페이지가 **dirty** 인지 확인하는 것이 좋습니다. **dirty가 아니면**, 파일의 내용을 **수정할 필요가 없습니다**. 스왑 아웃 후에는 **해당 페이지의 dirty 비트를 끄는 것**을 잊지 마십시오.