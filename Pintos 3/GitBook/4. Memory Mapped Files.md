이 섹션에서는 **메모리 매핑된 페이지(memory-mapped pages)** 를 구현합니다. **Anonymous 페이지**와 달리, 메모리 매핑된 페이지는 **파일 기반(file-backed) 매핑**입니다. 페이지의 내용은 기존 파일의 데이터를 **반영(mirror)** 합니다. 페이지 폴트가 발생하면, 즉시 물리 프레임이 할당되고 파일에서 내용을 읽어 **메모리로 복사**됩니다. 메모리 매핑된 페이지가 **언매핑(unmap)** 되거나 **스왑 아웃**될 때, 내용의 변경사항은 파일에 **반영**되어야 합니다.

---

## `mmap` and `munmap` System Call

메모리 매핑 파일을 위한 두 시스템 콜인 **`mmap`** 과 **`munmap`** 을 구현하십시오. 여러분의 VM 시스템은 `mmap` 영역의 페이지들을 **지연 로딩(lazy)** 해야 하며, 매핑의 **백킹 스토어**로 **매핑된 파일 자체**를 사용해야 합니다. 이 두 시스템 콜을 구현하기 위해 **`vm/file.c`** 에 정의된 **`do_mmap`** 과 **`do_munmap`** 을 구현·사용해야 합니다.

```c
void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
```

열려 있는 파일 `fd`의 **`offset` 바이트부터 `length` 바이트**를 **프로세스의 가상 주소 공간의 `addr`** 에 매핑합니다. **파일 전체**는 `addr`에서 시작하는 **연속적인 가상 페이지들**에 매핑됩니다. 파일 길이가 `PGSIZE`의 배수가 아닐 경우, **마지막 매핑 페이지의 일부 바이트가 파일 끝을 넘어 “튀어나오게”** 됩니다. 이 바이트들은 **페이지 폴트 시 0으로 채워야** 하며, **디스크로 다시 기록할 때는 버려야** 합니다. 성공 시, 이 함수는 파일이 매핑된 **가상 주소**를 반환합니다. 실패 시, **파일 매핑에 유효하지 않은 주소**인 **`NULL`** 을 반환해야 합니다.

다음과 같은 경우 **`mmap` 호출은 실패**할 수/해야 합니다:

- `fd`로 열린 파일의 길이가 **0바이트**인 경우: **실패할 수 있음**.
    
- `addr`가 **페이지 정렬(page-aligned)** 되어 있지 않거나, 매핑하려는 페이지 범위가 **이미 존재하는 어떤 매핑과도 겹치는 경우**(스택, 실행 시 로드된 페이지 포함): **반드시 실패**.
    
- 리눅스에서는 `addr == NULL`이면 커널이 적절한 주소를 찾지만, 단순화를 위해 **주어진 `addr`에 그대로 매핑을 시도**해도 됩니다. 따라서 **`addr == 0`이면 실패**해야 합니다(일부 Pintos 코드는 **가상 페이지 0이 매핑되지 않았음**을 가정함).
    
- `length == 0`이면 **실패**해야 합니다.
    
- **콘솔 입출력**을 나타내는 파일 디스크립터는 **매핑 불가**입니다.
    

메모리 매핑된 페이지들도 **anonymous 페이지와 마찬가지로 지연 할당**되어야 합니다. **`vm_alloc_page_with_initializer`** 또는 **`vm_alloc_page`** 를 사용하여 **페이지 객체**를 만들 수 있습니다.

```c
void munmap (void *addr);
```

이 함수는 **지정된 주소 범위 `addr`** 에 대한 매핑을 **언매핑**합니다. 이 `addr`는 **같은 프로세스**가 이전의 `mmap` 호출에서 **반환받았고 아직 언매핑되지 않은** 가상 주소여야 합니다.

모든 매핑은 **프로세스가 종료할 때(예: `exit` 또는 그 밖의 모든 방법)** **암묵적으로(unimplicitly) 언매핑**됩니다. 매핑이 **명시적으로**든 **암묵적으로**든 언매핑될 때, **프로세스가 쓰기한 페이지들은 파일로 다시 기록(write-back)** 되어야 하며, **쓰기하지 않은 페이지들은 기록하면 안 됩니다**. 그 후 해당 페이지들은 **프로세스의 가상 페이지 목록에서 제거**됩니다.

파일을 **닫거나 제거**하는 것은 그 파일의 **어떤 매핑도 언매핑하지 않습니다**. 매핑이 한 번 생성되면, **`munmap`이 호출되거나 프로세스가 종료될 때까지 유효**합니다(유닉스 관례). 자세한 내용은 **Removing an Open File** 을 참조하세요. 각 매핑에 대해 **독립적인 참조**를 얻기 위해 **`file_reopen`** 함수를 사용해야 합니다.

**두 개 이상의 프로세스가 동일한 파일을 매핑**하더라도, **일관된 데이터 보기를 제공해야 할 의무는 없습니다**. 유닉스는 두 매핑이 같은 **물리 페이지를 공유**하도록 하여 이를 처리하며, `mmap` 시스템 콜에는 페이지가 **공유(shared)** 인지 **개인(private, 즉 COW)** 인지를 **클라이언트가 지정**할 수 있는 인자도 존재합니다.

---

필요에 따라 `vm/vm.c`의 **`vm_file_init`** 과 **`vm_file_initializer`** 를 수정할 수 있습니다.

```c
void vm_file_init (void);
```

**파일 기반 페이지 서브시스템 초기화**를 수행합니다. 이 함수에서 **file-backed 페이지와 관련된 설정**을 할 수 있습니다.

```c
bool file_backed_initializer (struct page *page, enum vm_type type, void *kva);
```

**파일 기반 페이지**를 초기화합니다. 이 함수는 먼저 `page->operations`에 **file-backed 페이지용 핸들러**들을 설정합니다. 또한, **해당 메모리를 백업하는 파일** 등 **페이지 구조체의 정보**를 업데이트할 수 있습니다.

```c
static void file_backed_destroy (struct page *page);
```

연관된 파일을 **닫아** 파일 기반 페이지를 **파괴(destroy)** 합니다. 내용이 **dirty** 라면, **변경사항을 파일에 반영(write back)** 해야 합니다. 이 함수에서 **`struct page` 자체를 해제할 필요는 없습니다**. **`file_backed_destroy`의 호출자**가 이를 처리해야 합니다.