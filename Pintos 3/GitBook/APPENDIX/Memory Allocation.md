# Memory Allocation
Pintos에는 메모리 할당자가 두 가지 있습니다. 하나는 **페이지 단위**로 메모리를 할당하고, 다른 하나는 **임의 크기의 블록**을 할당할 수 있습니다.

---

## Page Allocator

`include/threads/palloc.h`에 선언된 **페이지 할당자**는 **페이지 단위**로 메모리를 할당합니다. 보통 한 번에 **한 페이지**를 할당하는 데 가장 자주 사용되지만, **연속된 여러 페이지**를 한 번에 할당할 수도 있습니다.

페이지 할당자는 자신이 관리하는 메모리를 **두 개의 풀**로 나눕니다. 이를 **커널 풀**과 **유저 풀**이라고 합니다. 기본적으로, 각 풀은 **1MB 위의 시스템 메모리**를 **절반씩** 가져갑니다. 이 분할은 커널 커맨드라인 옵션 **`ul`** 로 변경할 수 있습니다. 할당 요청은 **둘 중 하나의 풀**에서 충당됩니다. 한쪽 풀이 고갈되어도, 다른 풀에는 여전히 **여유 페이지**가 남아 있을 수 있습니다. **유저 풀**은 **사용자 프로세스**를 위한 메모리 할당에 사용되어야 하고, **커널 풀**은 그 **외의 모든 할당**에 사용되어야 합니다. 이는 **프로젝트 3부터** 중요해집니다. 그 전까지는 모든 할당을 **커널 풀**에서 하면 됩니다.

각 풀의 사용 현황은 **비트맵**으로 추적됩니다. **풀의 각 페이지당 1비트**가 대응됩니다. **n 페이지 할당 요청**이 오면, 비트맵에서 **연속된 n개의 0 비트(false)** 를 찾아 해당 페이지들이 **비어 있음**을 의미하도록 확인한 뒤, 그 비트들을 **1(true)** 로 설정해 **사용 중**으로 표시합니다. 이는 **“first fit”** 할당 전략입니다.

페이지 할당자는 **단편화(fragmentation)** 의 영향을 받습니다. 즉, 비어 있는 페이지가 n개 이상 있더라도, 그 사이사이에 사용 중인 페이지가 끼어 있으면 **연속된 n 페이지를 할당하지 못할 수** 있습니다. 극단적인 경우, **풀의 절반이 비어 있어도 2페이지 연속 할당이 불가능**할 수 있습니다. 반면, **단일 페이지 요청**은 단편화로 실패하지 않으므로, **연속 다중 페이지 요청은 가급적 줄이세요**.

**인터럽트 컨텍스트**에서는 페이지를 **할당할 수 없습니다**, 하지만 **해제는 가능**합니다.

페이지가 **해제**될 때, 디버깅 보조를 위해(“Debugging Tips” 참조) 그 **모든 바이트가 `0xcc`로 채워집니다.**

아래는 페이지 할당자의 타입과 함수들입니다.

```c
void *palloc_get_page (enum palloc_flags flags)
void *palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
```

각각 **한 페이지** 또는 **연속된 `page_cnt` 페이지**를 확보하여 반환합니다. 할당에 실패하면 **NULL 포인터**를 반환합니다.

`flags` 인자는 다음 플래그들의 **조합**이 될 수 있습니다:

- **PAL_ASSERT**  
    페이지를 할당할 수 없으면 **커널 패닉**을 발생시킵니다. 이는 **커널 초기화 중**에만 적합합니다. **사용자 프로세스**가 **커널 패닉**을 일으키도록 해서는 **안 됩니다**.
    
- **PAL_ZERO**  
    반환하기 전에 **할당된 모든 페이지의 바이트를 0으로 초기화**합니다. 설정하지 않으면, 새로 할당된 페이지의 내용은 **예측 불가능**합니다.
    
- **PAL_USER**  
    페이지를 **유저 풀**에서 가져옵니다. 설정하지 않으면 **커널 풀**에서 할당됩니다.
    

```c
void palloc_free_page (void *page)
void palloc_free_multiple (void *pages, size_t page_cnt)
```

각각 **한 페이지** 또는 **연속된 `page_cnt` 페이지**를 `pages`부터 **해제**합니다. 모든 페이지는 반드시 **`palloc_get_page()` 또는 `palloc_get_multiple()`로 확보된 것**이어야 합니다.

---

## Block Allocator

`threads/malloc.h`에 선언된 **블록 할당자**는 **임의 크기의 블록**을 할당할 수 있습니다. 이는 앞 절의 **페이지 할당자 위에 레이어링**되어 있습니다. **블록 할당자가 반환하는 블록은 모두 커널 풀**에서 가져옵니다.

블록 할당자는 **두 가지 전략**을 사용합니다.

1. **1 kB 이하**(페이지 크기의 1/4 이하) 블록에 대해:  
    요청 크기를 **2의 거듭제곱** 또는 **16바이트** 중 **더 큰 값**으로 **올림**합니다. 그런 다음 **그 크기 전용** 할당에만 사용되는 **하나의 페이지** 안에 **그룹화**합니다.
    
2. **1 kB 초과** 블록에 대해:  
    요청 크기(와 소량의 오버헤드)를 **가장 가까운 페이지 크기**로 **올림**한 뒤, 블록 할당자가 그 **페이지 수만큼 연속 페이지**를 **페이지 할당자에게 요청**합니다.
    

두 경우 모두, **요청한 크기**와 **실제 블록 크기** 사이의 차이는 **낭비**됩니다. 실제 OS는 이 낭비를 최소화하기 위해 할당자를 **세심하게 튜닝**하지만, **교육용 시스템**인 Pintos에서는 **중요하지 않습니다**.

페이지 할당자로부터 **페이지를 하나라도 얻을 수 있는 한**, **작은 할당은 항상 성공**합니다. 대부분의 작은 할당은 이미 확보된 **한 페이지의 일부**로 충족되므로 **새 페이지를 추가로 요청하지도 않습니다**. 반면에 **큰 할당은 항상 페이지 할당자를 호출**해야 하며, **2페이지 이상 연속 할당이 필요한 경우** 앞 절에서 논의한 **단편화**로 인해 실패할 수 있습니다. 따라서 코드에서 **큰 할당의 개수를 최소화**해야 하며, 특히 **약 4 kB를 초과하는** 할당을 줄이세요.

블록이 **해제**될 때, 디버깅 보조를 위해 그 **모든 바이트가 `0xcc`로 채워집니다**(“Debugging Tips” 참조).

블록 할당자는 **인터럽트 컨텍스트에서 호출할 수 없습니다**.

아래는 블록 할당자 함수들이며, **표준 C 라이브러리**의 **동명 함수 인터페이스**와 동일합니다.

```c
void *malloc (size_t size)
```

**커널 풀**에서 최소 `size` 바이트 길이의 **새 블록**을 확보하여 반환합니다. `size`가 **0**이거나 메모리가 **부족**하면 **NULL**을 반환합니다.

```c
void *calloc (size_t a, size_t b)
```

**커널 풀**에서 최소 `a * b` 바이트 길이의 **새 블록**을 확보하여 반환합니다. 블록의 내용은 **0으로 초기화**됩니다. `a` 또는 `b`가 **0**이거나 메모리가 **부족**하면 **NULL**을 반환합니다.

```c
void *realloc (void *block, size_t new_size)
```

`block`을 **`new_size` 바이트로 리사이즈**를 시도하며, 이 과정에서 **이동**될 수 있습니다. 성공 시 **새 블록**을 반환하고, **기존 블록에는 더 이상 접근하면 안 됩니다**. 실패 시 **NULL**을 반환하며, **기존 블록은 여전히 유효**합니다.  
`block == NULL`인 호출은 **`malloc()`과 동일**합니다. `new_size == 0`인 호출은 **`free()`와 동일**합니다.

```c
void free (void *block)
```

`block`을 **해제**합니다. `block`은 이전에 **`malloc()`/`calloc()`/`realloc()`** 으로 반환되었고, 아직 **해제되지 않은** 것이어야 합니다.