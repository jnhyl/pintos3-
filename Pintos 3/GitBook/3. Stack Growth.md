# Stack Growth
프로젝트 2에서는 스택이 `USER_STACK`에서 시작하는 **단일 페이지**였고, 프로그램의 실행은 이 크기에 의해 제한되었습니다. 이제는 스택이 현재 크기를 넘어 **성장**하면, 필요한 만큼 **추가 페이지를 할당**합니다.

**오직 “스택 접근으로 보이는” 경우에만** 추가 페이지를 할당하십시오. **스택 접근을 다른 접근과 구별**하려는 **휴리스틱**을 고안하세요.

사용자 프로그램이 **스택 포인터 아래로 쓰기**를 수행한다면 이는 버그입니다. 왜냐하면 일반적인 실제 OS는 언제든지 프로세스를 인터럽트하여 **신호(signal)** 를 전달할 수 있고, 이는 스택의 데이터를 수정하기 때문입니다. 그러나 x86-64의 **PUSH** 명령은 **스택 포인터를 조정하기 전에 접근 권한을 검사**하므로, **스택 포인터보다 8바이트 아래에서** 페이지 폴트를 유발할 수 있습니다.

사용자 프로그램의 **현재 스택 포인터 값을 얻을 수 있어야** 합니다. **시스템 콜** 내부나 **사용자 프로그램이 발생시킨 페이지 폴트**의 경우, 각각 `syscall_handler()` 또는 `page_fault()`에 전달되는 `struct intr_frame`의 **`rsp` 멤버**에서 이를 가져올 수 있습니다. 만약 **페이지 폴트에 의존하여** 잘못된 메모리 접근을 감지한다면, 또 다른 경우를 처리해야 합니다. 즉, **커널에서 페이지 폴트가 발생**하는 경우입니다. 프로세서는 **예외가 사용자 모드에서 커널 모드로 전환**을 일으킬 때만 스택 포인터를 저장하므로, `page_fault()`에 전달되는 `struct intr_frame`에서 `rsp`를 읽으면 **정의되지 않은 값**이 되어 **사용자 스택 포인터가 아닐 수 있습니다**. 따라서 **다른 방법을 마련**해야 합니다. 예를 들어, **사용자→커널 최초 전이 시점**에 `rsp`를 **`struct thread`에 저장**하는 방식이 있습니다.

스택 성장 기능을 구현하십시오. 이를 위해 먼저 `vm/vm.c`의 **`vm_try_handle_fault`** 를 수정하여 **스택 성장을 식별**해야 합니다. 스택 성장을 식별한 후에는, **`vm/vm.c`의 `vm_stack_growth`** 를 호출하여 스택을 확장하세요. **`vm_stack_growth`** 를 구현해야 합니다.

```c
bool vm_try_handle_fault (struct intr_frame *f, void *addr,
    bool user, bool write, bool not_present);
```

이 함수는 `userprog/exception.c`의 `page_fault`에서 **페이지 폴트 예외를 처리하는 동안 호출**됩니다. 이 함수에서, 해당 페이지 폴트가 **스택 성장을 위한 유효한 경우인지** 확인해야 합니다. **스택 성장으로 처리할 수 있음**을 확신했다면, **폴트가 발생한 주소**를 인자로 **`vm_stack_growth`** 를 호출하십시오.

```c
void vm_stack_growth (void *addr);
```

스택 크기를 **하나 이상의 anonymous 페이지를 할당**하여 증가시켜, **`addr`가 더 이상 폴트가 발생하는 주소가 되지 않도록** 합니다. **할당을 처리할 때 `addr`를 `PGSIZE` 경계로 내림(round down)** 했는지 반드시 확인하십시오.

대부분의 OS는 **스택 크기에 절대적인 한계**를 둡니다. 일부 OS는 `ulimit`(많은 유닉스 시스템) 같은 명령으로 **사용자가 조정 가능**하게 합니다. 많은 GNU/Linux 시스템에서 기본 한도는 **8MB**입니다. 본 프로젝트에서는 **스택 크기를 최대 1MB로 제한**해야 합니다.

이제 **모든 스택 성장 관련 테스트 케이스**를 통과해야 합니다.