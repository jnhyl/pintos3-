# Memory Management
가상 메모리 시스템을 지원하려면, **가상 페이지**와 **물리 프레임**을 효과적으로 관리해야 합니다. 이는 어떤 (가상 혹은 물리) 메모리 영역이 **사용 중인지**, **무엇을 위해** 사용되는지, **누가** 사용하는지 등을 추적해야 함을 의미합니다. 먼저 **보조(보충) 페이지 테이블**을 다룬 다음, **물리 프레임**을 다루게 됩니다. 이해를 돕기 위해, 여기서는 “**page**”라는 용어를 **가상 페이지**에, “**frame**”이라는 용어를 **물리 페이지**에 사용합니다.

---

## Page Structure and Operations

### `struct page`

`include/vm/vm.h`에 정의된 **페이지(page)** 는 가상 메모리에서의 페이지를 표현하는 구조체입니다. 이 구조체는 해당 페이지에 대해 알아야 할 모든 **필수 데이터**를 저장합니다. 현재 템플릿에서 이 구조체는 다음과 같습니다:

```c
struct page {
  const struct page_operations *operations;
  void *va;              /* Address in terms of user space */
  struct frame *frame;   /* Back reference for frame */

  union {
    struct uninit_page uninit;
    struct anon_page anon;
    struct file_page file;
#ifdef EFILESYS
    struct page_cache page_cache;
#endif
  };
};
```

이 구조체에는 **페이지 연산(아래 참조)**, **가상 주소(va)**, **물리 프레임(frame)** 이 있습니다. 추가로 **union 필드**가 있습니다. **union**은 하나의 메모리 영역에 **여러 타입 중 하나**의 값을 저장할 수 있게 하는 특수한 데이터 타입입니다. 멤버가 여러 개 존재하지만, **한 시점에는 오직 하나의 멤버만** 값(유효한 데이터)을 가집니다. 이는 우리 시스템의 한 페이지가 `uninit_page`, `anon_page`, `file_page`, 혹은 `page_cache` 중 **하나의 형태**가 될 수 있음을 의미합니다. 예를 들어, 어떤 페이지가 **anonymous 페이지**(“Anonymous Page” 참조)라면, 해당 `struct page`는 멤버 중 하나로 `struct anon_page anon`을 갖게 됩니다. 그리고 `anon_page`에는 **anonymous 페이지**에 대해 유지해야 할 모든 필수 정보가 들어갑니다.

---

### Page Operations

앞서 설명했듯이, 그리고 `include/vm/vm.h`에 정의된 대로, 페이지는 `VM_UNINIT`, `VM_ANON`, 또는 `VM_FILE`이 될 수 있습니다. 각 페이지에 대해 수행되어야 하는 동작으로는 **swap-in**, **swap-out**, **파괴(destroy)** 등이 있습니다. 페이지 타입마다 이러한 동작에 필요한 **절차와 작업이 서로 다릅니다**. 다시 말해, `VM_ANON` 페이지와 `VM_FILE` 페이지에는 **서로 다른 destroy 함수**가 호출되어야 합니다. 하나의 방법은 각 함수에서 **switch-case 문**으로 타입별 처리를 하는 것입니다. 여기서는 이를 다루기 위해 **객체지향 프로그래밍(OOP)의 “클래스 상속” 개념**을 도입합니다. 물론 C 언어에는 실제 “클래스”나 “상속”이 없지만, **함수 포인터(function pointer)** 를 활용하여 이 개념을 실현합니다. 이는 **Linux 같은 실제 운영체제 코드**에서도 유사하게 사용되는 방식입니다.

**함수 포인터**는 지금까지 배운 다른 포인터들처럼 **메모리 내의 함수(실행 코드)를 가리키는 포인터**입니다. 함수 포인터는 **런타임 값**에 따라 **조건 검사 없이** 특정 함수를 간단히 호출하는 수단을 제공하기 때문에 유용합니다. 우리 경우, 코드 레벨에서는 단순히 `destroy(page)`를 호출하면 충분하며, **컴파일러가 올바른 함수 포인터를 통해** 페이지 타입에 맞는 **적절한 destroy 루틴**을 호출하게 됩니다.

`struct page_operations`는 `include/vm/vm.h`에 정의되어 있으며, **3개의 함수 포인터**를 담는 **함수 테이블**로 볼 수 있습니다.

```c
struct page_operations {
  bool (*swap_in) (struct page *, void *);
  bool (*swap_out) (struct page *);
  void (*destroy) (struct page *);
  enum vm_type type;
};
```

이제 `page_operations` 구조체가 어디에 있는지 살펴봅시다. `include/vm/vm.h`의 `struct page`를 보면, `operations`라는 필드가 있음을 볼 수 있습니다. `vm/file.c`로 가면, 함수 프로토타입들보다 앞에 **`page_operations` 구조체 `file_ops`** 가 선언되어 있는 것을 볼 수 있습니다. 이것이 **file-backed 페이지**를 위한 함수 포인터 테이블입니다. 이 중 `.destroy` 필드는 `file_backed_destroy` 값을 가지며, 이는 **해당 페이지를 파괴**하는 함수이고 같은 파일에 정의되어 있습니다.

이제 **함수 포인터 인터페이스**로 `file_backed_destroy`가 어떻게 호출되는지 이해해 봅시다. `vm/vm.c`의 `vm_dealloc_page(page)`가 호출되었고, 이 `page`가 **file-backed 페이지(VM_FILE)** 라고 가정합시다. 함수 내부에서는 `destroy(page)`를 호출합니다. `destroy(page)`는 `include/vm/vm.h`에 다음과 같은 매크로로 정의되어 있습니다:

```c
#define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
```

이는 `destroy`를 호출하는 것이 사실상 `(page)->operations->destroy(page)`를 호출하는 것임을 알려줍니다. 즉, **페이지 구조체에 저장된 함수 포인터**에서 destroy 함수를 가져와 호출합니다. 해당 페이지가 `VM_FILE`이므로, 그 `.destroy` 필드는 `file_backed_destroy`를 가리킵니다. 결과적으로 **file-backed 페이지에 대한 destroy 루틴**이 수행됩니다.

---

## Implement Supplemental Page Table

현재 시점에서 여러분의 Pintos는 **페이지 테이블(pml4)** 을 갖고 있어, 메모리의 가상–물리 매핑을 관리합니다. 하지만 이것만으로는 충분하지 않습니다. 앞 절에서 논의했듯이, **페이지 폴트 처리**와 **자원 관리**를 위해 각 페이지에 대한 **추가 정보**를 보관할 **보조(보충) 페이지 테이블**이 필요합니다. 따라서 프로젝트 3의 **첫 번째 작업**으로, 보조 페이지 테이블을 위한 **기본 기능**들을 구현하는 것을 권장합니다.

`vm/vm.c`에 **보조 페이지 테이블 관리 함수들**을 구현하십시오.

먼저, Pintos에서 **보조 페이지 테이블을 어떻게 설계**할지 결정해야 합니다. 여러분만의 보조 페이지 테이블을 설계한 뒤, 그 설계에 맞춰 아래의 **세 함수를 구현**하십시오.

```c
void supplemental_page_table_init (struct supplemental_page_table *spt);
```

보조 페이지 테이블을 **초기화**합니다. 보조 페이지 테이블에 사용할 **자료구조의 선택**은 여러분에게 달려 있습니다. 이 함수는 **새 프로세스가 시작될 때**(`userprog/process.c`의 `initd`)와 **프로세스가 fork될 때**(`userprog/process.c`의 `__do_fork`) 호출됩니다.

```c
struct page *spt_find_page (struct supplemental_page_table *spt, void *va);
```

주어진 보조 페이지 테이블에서, 가상 주소 `va`에 대응하는 `struct page`를 **찾아 반환**합니다. 실패 시 `NULL`을 반환합니다.

```c
bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);
```

주어진 보조 페이지 테이블에 `struct page`를 **삽입**합니다. 이 함수는 **해당 가상 주소가 이미 존재하지 않는지**를 **반드시 검사**해야 합니다.

---

## Frame Management

이제부터 모든 페이지는 **구성 시점의 메모리에 대한 메타데이터만** 보유하는 것이 아닙니다. 따라서 **물리 메모리를 관리하는 다른 체계**가 필요합니다. `include/vm/vm.h`에는 **물리 메모리**를 표현하는 `struct frame`이 존재합니다. 현재 이 구조체는 다음과 같습니다:

```c
/* The representation of "frame" */
struct frame {
  void *kva;
  struct page *page;
};
```

필드는 두 개뿐입니다 — `kva`(kernel virtual address, **커널 가상 주소**)와 `page`(**페이지 구조체**)입니다. 프레임 관리 인터페이스를 구현하면서 **필요하다면 멤버를 추가**해도 됩니다.

`vm/vm.c`에 **`vm_get_frame`, `vm_claim_page`, `vm_do_claim_page`** 를 구현하십시오.

```c
static struct frame *vm_get_frame (void);
```

`palloc_get_page`를 호출하여 **user pool**에서 **새 물리 페이지**를 가져옵니다. user pool에서 페이지를 성공적으로 얻었다면, **프레임을 할당**하고, 그 **멤버들을 초기화**한 후 이를 반환합니다. `vm_get_frame`을 구현한 뒤에는 **모든 사용자 공간 페이지 할당(`PALLOC_USER`)을 반드시 이 함수**를 통해 수행해야 합니다. **지금 단계에서는** 페이지 할당 실패 시의 **swap out 처리는 필요 없습니다**. 그런 경우는 일단 `PANIC("todo")`로 표시해 두십시오.

```c
bool vm_do_claim_page (struct page *page);
```

페이지를 **claim(= 물리 프레임을 할당)** 합니다. 먼저 `vm_get_frame`을 호출해 프레임을 얻습니다(템플릿에 이미 일부가 제공됨). 그런 다음 **MMU 설정**이 필요합니다. 즉, **페이지 테이블에 가상 주소 → 물리 주소 매핑을 추가**해야 합니다. 반환값은 **작업 성공 여부**를 나타내야 합니다.

```c
bool vm_claim_page (void *va);
```

`va`에 해당하는 페이지를 **claim**합니다(= 해당 주소에 대한 페이지를 **할당**). 먼저 해당 주소의 페이지를 **가져오고**, 이어서 `vm_do_claim_page`를 그 페이지로 호출해야 합니다.